using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Freecon.Core.Interfaces;
using System.Reflection;
using System.Text.RegularExpressions;
using Server.Managers;


namespace Freecon.Models.UI
{
    public static class UIHelper
    {
        /// <summary>
        /// Uses reflection to generate (displayName, displayData) key value pairs
        /// the returned dictionary always contains a <string, string> ("ObjectType", [ObjectType].ToString()) to identify the serialized object type
        /// If UIAttribute.DisplayName == "", the UIField DisplayName will be generated by splitting the property name at capital letters (assuming we use camel case)
        /// A property/field marked with the attribute [UIProperty] will be added to the dictionary as a kvp<string, UIField>(DisplayName, UIField)
        /// A property/field marked with the attribute [UICollection] will be added to the dictionary as a kvp<string, UIGroup>(DisplayName, UIGroup)
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static List<KeyValuePair<string, object>> GetUIData(IHasUIData obj)
        {
            
            var UIData = new List<KeyValuePair<string, object>>();
            UIData.Add(new KeyValuePair<string, object>("ObjectType", obj.GetType().Name));
            GetUIFields(obj, ref UIData);
            GetUIGroups(obj, ref UIData);

            return UIData;         
        }

        static void GetUIFields(IHasUIData obj, ref List<KeyValuePair<string, object>> UIData)
        {

            var properties = obj.GetType()
                .GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                .Where(prop => Attribute.IsDefined(prop, typeof(UIProperty)));

            var fields = obj.GetType()
                .GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                .Where(field => Attribute.IsDefined(field, typeof(UIProperty)));
            

            foreach (var prop in properties)
            {
                var uiattribute = prop.GetCustomAttribute(typeof(UIProperty)) as UIProperty;

                var displayName = uiattribute.DisplayName == "" ? prop.Name.SplitCamelCase() : uiattribute.DisplayName;
                var displayValue = prop.GetValue(obj).ToString();
                var displayOrder = uiattribute.DisplayOrder;
                var units = uiattribute.Units;
                var isDisplayed = uiattribute.IsDisplayed;

                UIData.Add(new KeyValuePair<string, object>(displayName, new UIField { DisplayValue = displayValue, DisplayOrder = displayOrder, Units = units, IsDisplayed = isDisplayed }));
            }

            foreach (var field in fields)
            {
                var uiattribute = field.GetCustomAttribute(typeof(UIProperty)) as UIProperty;

                var displayName = uiattribute.DisplayName == "" ? field.Name.SplitCamelCase() : uiattribute.DisplayName;
                var displayValue = field.GetValue(obj).ToString();
                var displayOrder = uiattribute.DisplayOrder;
                var units = uiattribute.Units;
                var isDisplayed = uiattribute.IsDisplayed;

                UIData.Add(new KeyValuePair<string, object>(displayName, new UIField { DisplayValue = displayValue, DisplayOrder = displayOrder, Units = units, IsDisplayed = isDisplayed }));
            }    

        }

        private static void GetUIGroups(IHasUIData obj, ref List<KeyValuePair<string, object>> UIData)
        {

            var properties = obj.GetType()
                .GetProperties(BindingFlags.Public | BindingFlags.NonPublic |BindingFlags.Instance)
                .Where(prop => Attribute.IsDefined(prop, typeof(UICollection)));

            var fields = obj.GetType()
                .GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                .Where(field => Attribute.IsDefined(field, typeof(UICollection)));


            foreach (var prop in properties)
            {
                var uiattribute = prop.GetCustomAttribute(typeof(UICollection)) as UICollection;

                if (prop.PropertyType.GetInterface(typeof(IHasUIData).Name) == null)
                {
                    continue;
                }

                var displayName = uiattribute.DisplayName == "" ? prop.Name.SplitCamelCase() : uiattribute.DisplayName;
                var uifields = new List<KeyValuePair<string, object>>();
                GetUIFields((IHasUIData)prop.GetValue(obj), ref uifields);

                UIData.Add(new KeyValuePair<string, object>(displayName, new UIGroup(uifields)));
            }

            foreach (var field in fields)
            {
                var uiattribute = field.GetCustomAttribute(typeof(UICollection)) as UICollection;

                if (field.FieldType.GetInterface(typeof(IHasUIData).Name) == null)
                {
                    continue;
                }

                var displayName = uiattribute.DisplayName == "" ? field.Name.SplitCamelCase() : uiattribute.DisplayName;
                var uifields = new List<KeyValuePair<string, object>>();
                GetUIFields((IHasUIData)field.GetValue(obj), ref uifields);

                UIData.Add(new KeyValuePair<string, object>(displayName, new UIGroup(uifields)));
            }

        }

        /// <summary>
        ///  I'm pretty sure regex is slow as shit, but this'll save us a lot of dev headache in the short term, having to specify a DisplayName for each multi-worded property
        ///  Can fix later
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        static string SplitCamelCase(this string source)
        {
            string retString = "";

            //I should really learn regex to do this in one step...
            string[] words = Regex.Split(source, @"(?<!^)(?=[A-Z])");

            for (var i = 0; i < words.Length - 1; i++)
            {
                retString += words[i] + " ";
            }

            retString += words[words.Length - 1];

            return retString;
        }
    }

    public class UIField
    {
        public string DisplayValue;
        public int DisplayOrder;
        public string Units;
        public bool IsDisplayed;
    }

    public class UIGroup
    {
        public List<KeyValuePair<string, object>> UIFields { get; protected set; }

        public UIGroup(List<KeyValuePair<string, object>> uiFields)
        {
            UIFields = uiFields;
        }
    }
}
