using System;
using System.Collections.Generic;
using System.Linq;
using Freecon.Core.Interfaces;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Concurrent;


namespace Freecon.Models.UI
{
    static public class UIHelper
    {

        static ConcurrentDictionary<Type, IEnumerable<FieldInfo>> _UIPropertyFieldCache = new ConcurrentDictionary<Type, IEnumerable<FieldInfo>>();
        static ConcurrentDictionary<Type, IEnumerable<PropertyInfo>> _UIPropertyPropertyCache = new ConcurrentDictionary<Type, IEnumerable<PropertyInfo>>();

        static ConcurrentDictionary<Type, IEnumerable<FieldInfo>> _UICollectionFieldCache = new ConcurrentDictionary<Type, IEnumerable<FieldInfo>>();
        static ConcurrentDictionary<Type, IEnumerable<PropertyInfo>> _UICollectionPropertyCache = new ConcurrentDictionary<Type, IEnumerable<PropertyInfo>>();


        /// <summary>
        /// Uses reflection to recursively generate UIDisplayData object
        /// If UIAttribute.DisplayName == "", the UIField DisplayName will be generated by splitting the property name at capital letters (assuming we use camel case)
        /// A property/field marked with the attribute [UIProperty] will be added UIDisplayData.UIFields
        /// A property/field marked with the attribute [UICollection] will be recursively processed and added to UIDisplayData.NestedUIDisplayData
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        static public UIDisplayData GetUIData(IHasUIData obj)
        {
            var displayData = new UIDisplayData { DisplayName = obj.UIDisplayName };
            PopulateUIData(obj, ref displayData);
            return displayData;
        }



        /// <summary>
        /// If displayName == null, DisplayName is set to obj.UIDisplayName
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="UIData"></param>
        /// <param name="displayName"></param>
        static void PopulateUIData(IHasUIData obj, ref UIDisplayData UIData)
        {
            UIData.ObjectType = obj.GetType().Name;
            GetUIFields(obj, ref UIData);
            GetUICollections(obj, ref UIData);

        }


        /// <summary>
        /// Get UI data from simple (non-class) members marked with UIProperty
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="UIData"></param>
        static void GetUIFields(IHasUIData obj, ref UIDisplayData UIData)
        {
            foreach (var prop in GetUIPropertyProperties(obj))
            {
                var uiattribute = prop.GetCustomAttribute(typeof(UIProperty)) as UIProperty;

                var propertyName = prop.Name;
                var displayName = uiattribute.DisplayName == "" ? prop.Name.SplitCamelCase() : uiattribute.DisplayName;
                var displayValue = prop.GetValue(obj).ToString();
                var displayOrder = uiattribute.DisplayOrder;
                var units = uiattribute.Units;
                var isDisplayed = uiattribute.IsDisplayed;
                var type = prop.PropertyType.Name;

                UIData.UIFields.Add(propertyName, new UIField { DisplayName = displayName, DisplayValue = displayValue, DisplayOrder = displayOrder, Units = units, IsDisplayed = isDisplayed, Type = type });
            }

            foreach (var field in GetUIPropertyFields(obj))
            {
                var uiattribute = field.GetCustomAttribute(typeof(UIProperty)) as UIProperty;

                var propertyName = field.Name;
                var displayName = uiattribute.DisplayName == "" ? field.Name.SplitCamelCase() : uiattribute.DisplayName;
                var displayValue = field.GetValue(obj).ToString();
                var displayOrder = uiattribute.DisplayOrder;
                var units = uiattribute.Units;
                var isDisplayed = uiattribute.IsDisplayed;
                var type = field.FieldType.Name;

                UIData.UIFields.Add(propertyName, new UIField { DisplayName = displayName, DisplayValue = displayValue, DisplayOrder = displayOrder, Units = units, IsDisplayed = isDisplayed, Type = type });
            }

        }

        /// <summary>
        /// Get UI data from complex (class) members marked with UICollection
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="UIData"></param>
        static void GetUICollections(IHasUIData obj, ref UIDisplayData UIData)
        {
            foreach (var prop in GetUICollectionProperties(obj))
            {
                var uiattribute = prop.GetCustomAttribute(typeof(UICollection)) as UICollection;
                var propertyName = prop.Name;
                var displayName = uiattribute.DisplayName == "" ? prop.Name.SplitCamelCase() : uiattribute.DisplayName;
                var nestedData = new UIDisplayData() { DisplayName = displayName };

                if (prop.PropertyType.GetInterface(typeof(IHasUIData).Name) != null)
                {
                    nestedData.ObjectType = prop.PropertyType.Name;
                    PopulateUIData((IHasUIData)prop.GetValue(obj), ref nestedData);
                    UIData.NestedUIDisplayData.Add(propertyName, nestedData);

                }
                else if (prop.PropertyType.GetInterface(typeof(IEnumerable).Name) != null)
                {
                    nestedData.ObjectType = GetFullType(prop.PropertyType);
                    PopulateUIData((IEnumerable)prop.GetValue(obj), ref nestedData);
                    UIData.NestedUIDisplayData.Add(propertyName, nestedData);
                }

            }

            foreach (var field in GetUICollectionFields(obj))
            {
                var uiattribute = field.GetCustomAttribute(typeof(UICollection)) as UICollection;
                var fieldName = field.Name;
                var displayName = uiattribute.DisplayName == "" ? field.Name.SplitCamelCase() : uiattribute.DisplayName;
                var nestedData = new UIDisplayData() { DisplayName = displayName };


                if (field.FieldType.GetInterface(typeof(IHasUIData).Name) != null)
                {
                    nestedData.ObjectType = field.FieldType.Name;
                    PopulateUIData((IHasUIData)field.GetValue(obj), ref nestedData);
                    UIData.NestedUIDisplayData.Add(fieldName, nestedData);
                }
                else if (field.FieldType.GetInterface(typeof(IEnumerable).Name) != null)
                {
                    nestedData.ObjectType = GetFullType(field.FieldType);
                    PopulateUIData((IEnumerable)field.GetValue(obj), ref nestedData);
                    UIData.NestedUIDisplayData.Add(fieldName, nestedData);
                }


            }

        }


        /// <summary>
        /// Get UI data for IEnumerable<IHasUIData> and Dictionary<t, IHasUIData>
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="UIData"></param>
        static void PopulateUIData(IEnumerable obj, ref UIDisplayData UIData)
        {
            var genericArgs = obj.GetType().GetGenericArguments();
            var t = obj.GetType();

            if (genericArgs[0].GetInterface(typeof(IHasUIData).Name) != null)
            {
                int i = 0;
                foreach (var v in obj)
                {
                    var nestedData = new UIDisplayData();
                    nestedData.DisplayName = ((IHasUIData)v).UIDisplayName;
                    PopulateUIData((IHasUIData)v, ref nestedData);
                    UIData.NestedUIDisplayData.Add(i.ToString(), nestedData);
                    i++;
                }
            }
            else if (genericArgs[0].GetInterface(typeof(IEnumerable).Name) != null)
            {
                //IEnumerable<IEnumerable>, don't know what to do about the display name...
                int i = 0;
                foreach (var v in obj)
                {
                    var nestedData = new UIDisplayData();
                    nestedData.DisplayName = ((IHasUIData)v.GetType().GetProperty("Key").GetValue(v)).UIDisplayName;
                    UIData.NestedUIDisplayData.Add(i.ToString(), nestedData);
                    i++;
                }

            }
            else if (genericArgs.Length == 2 && genericArgs[1].GetInterface(typeof(IHasUIData).Name) != null)
            {
                //Dictionaries have 2 generic arguments
                //if Value implements IHasUIData:
                foreach (var v in obj)
                {
                    var nestedData = new UIDisplayData();
                    nestedData.DisplayName = ((IHasUIData)v.GetType().GetProperty("Value").GetValue(v)).UIDisplayName;
                    PopulateUIData((IHasUIData)(v.GetType().GetProperty("Value").GetValue(v)), ref nestedData);
                    UIData.NestedUIDisplayData.Add(v.GetType().GetProperty("Key").GetValue(v).ToString(), nestedData);
                }

            }

        }

        public static string SplitCamelCase(this string source)
        {
            string retString = "";

            //I should really learn regex to do this in one step...
            string[] words = Regex.Split(source, @"(?<!^)(?=[A-Z])", RegexOptions.Compiled);
            for (int i = 0; i < words.Length - 1; i++)
            {
                retString += words[i] + " ";
            }

            retString += words[words.Length - 1];

            return retString;


        }

        static IEnumerable<FieldInfo> GetUIPropertyFields(IHasUIData obj)
        {
            var t = obj.GetType();

            if (_UIPropertyFieldCache.ContainsKey(t))
            {
                return _UIPropertyFieldCache[t];
            }
            else
            {
                var fields = t.GetFields(BindingFlags.Public | BindingFlags.NonPublic |
                            BindingFlags.Instance).Where(
                   field => Attribute.IsDefined(field, typeof(UIProperty)));

                _UIPropertyFieldCache.TryAdd(t, fields);
                return fields;
            }
        }

        static IEnumerable<FieldInfo> GetUICollectionFields(IHasUIData obj)
        {
            var t = obj.GetType();

            if (_UICollectionFieldCache.ContainsKey(t))
            {
                return _UICollectionFieldCache[t];
            }
            else
            {
                var fields = t.GetFields(BindingFlags.Public | BindingFlags.NonPublic |
                                     BindingFlags.Instance).Where(
                            field => Attribute.IsDefined(field, typeof(UICollection)));

                _UICollectionFieldCache.TryAdd(t, fields);
                return fields;
            }
        }

        static IEnumerable<PropertyInfo> GetUIPropertyProperties(IHasUIData obj)
        {
            var t = obj.GetType();

            if (_UIPropertyPropertyCache.ContainsKey(t))
            {
                return _UIPropertyPropertyCache[t];
            }
            else
            {
                var properties = t.GetProperties(BindingFlags.Public | BindingFlags.NonPublic |
                         BindingFlags.Instance).Where(
                prop => Attribute.IsDefined(prop, typeof(UIProperty)));

                _UIPropertyPropertyCache.TryAdd(t, properties);
                return properties;
            }

        }

        static IEnumerable<PropertyInfo> GetUICollectionProperties(IHasUIData obj)
        {


            var t = obj.GetType();

            if (_UICollectionPropertyCache.ContainsKey(t))
            {
                return _UICollectionPropertyCache[t];
            }
            else
            {
                var properties = t.GetProperties(BindingFlags.Public | BindingFlags.NonPublic |
                          BindingFlags.Instance).Where(
                 prop => Attribute.IsDefined(prop, typeof(UICollection)));

                _UICollectionPropertyCache.TryAdd(t, properties);
                return properties;
            }
        }

        static string GetFullType(Type t)
        {
            var genericArgs = t.GetGenericArguments();
            if (genericArgs.Length == 0)
                return t.Name;
            else
            {
                string retString = t.Name + "<" + genericArgs[0].Name;
                for (int i = 1; i < genericArgs.Length; i++)
                {
                    retString += "," + genericArgs[i].Name;
                }

                retString += ">";
                return retString;
            }
        }

    }

    public class UIDisplayData
    {
        public string ObjectType;
        public string DisplayName;

        /// <summary>
        /// Key is PropertyName
        /// </summary>
        public Dictionary<string, UIField> UIFields;

        /// <summary>
        /// If obj is a single IHasUIData object, Key is PropertyName
        /// If obj is IDictionary<t,IHasUIData>, key is Key.ToString()
        /// If obj is an IEnumerable<IHasUIData>, key is just a unique int
        /// </summary>
        public Dictionary<string, UIDisplayData> NestedUIDisplayData;

        public UIDisplayData()
        {
            UIFields = new Dictionary<string, UIField>();
            NestedUIDisplayData = new Dictionary<string, UIDisplayData>();
        }


    }

    public class UIField
    {
        public string Type;
        public string DisplayName;
        public string DisplayValue;
        public int DisplayOrder;
        public string Units;
        public bool IsDisplayed;
    }

}